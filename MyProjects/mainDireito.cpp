// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <iomanip>
#include <numeric>
#include <random>
#include <unistd.h>
#include "../OptFrame/Util/RandGenMersenneTwister.hpp"
#include "../OptFrame/Util/printable.h"
#include "../OptFrame/RandGen.hpp"

using namespace std;
using namespace optframe;

//int computeFacts(vector<vector<pair<int, int> > > votes, vector<vector<int> > profileWeights, vector<vector<int> > citizensProfile)
//{
//	int nFacts = votes.size();
//	int nVoters = citizensProfile[0].size();
//
//
//	for(int f=0;f<nFacts;f++)
//	{
//		vector<int> scores;
//		int sum = 0;
//		for(int c=0;c<nVoters;c++)
//			{
//			sum+=votes[f][c].first *
//			}
//	}
//
//}

struct solDireitoDoFuturo
{
	vector<vector<int> > profileWeights;
	vector<vector<pair<int, int> > > votes;
	vector<int> relevantFacts;
	double stdProfile;

	solDireitoDoFuturo(vector<vector<int> > _profileWeights, vector<vector<pair<int, int> > > _votes, vector<int> _relevantFacts, double _stdProfile) :
			profileWeights(_profileWeights), votes(_votes), relevantFacts(_relevantFacts), stdProfile(_stdProfile)
	{

	}
//
	friend ostream & operator<<(ostream & os, const solDireitoDoFuturo& sol)
	{

		os << "=======================================" << endl;
		os << "==========PRINTING SOL ===============" << endl;
		os << "=======================================" << endl;
		os << "Profile weights:" << endl;
		os << sol.profileWeights << endl;
		os << "stdProfile:" << endl;
		os << sol.stdProfile << endl;
		os << "relevantFacts:" << endl;
		os << sol.relevantFacts << endl;
		os << "=======================================" << endl;

		return os;
	}

};

bool addSolution(vector<solDireitoDoFuturo>& nonDom, solDireitoDoFuturo candidateSol)
{
	bool added = false;

	for (int ind = 0; ind < nonDom.size(); ind++)
	{
		vector<int> a = nonDom[ind].relevantFacts;
		vector<int> b = candidateSol.relevantFacts;
		sort(a.begin(), a.end());
		sort(b.begin(), b.end());

//		if (nonDom[ind].relevantFacts == candidateSol.relevantFacts)
		if (a == b)
		{
			if (nonDom[ind].stdProfile <= candidateSol.stdProfile)
			{
				return false;
			}
			else
			{
				nonDom.erase(nonDom.begin() + ind);
				ind--;
			}
		}

	}
	added = true;
	nonDom.push_back(candidateSol);

	return added;
}

static bool comparacao(pair<double, int> a, pair<double, int> b)
{
	return (a.first < b.first);
}

vector<int> returnMostRelevantFact(vector<double> factsFinalWeights)
{
	vector<int> relevantFacts;
	int nFacts = factsFinalWeights.size();
	vector<pair<double, int> > weightsPerIndex;

	for (int f = 0; f < nFacts; f++)
	{
		weightsPerIndex.push_back(make_pair(factsFinalWeights[f], f));
	}

	sort(weightsPerIndex.begin(), weightsPerIndex.end(), comparacao);

	for (int f = 0; f < nFacts; f++)
		if (weightsPerIndex[f].first < 0)
			relevantFacts.push_back(weightsPerIndex[f].second);
		else
			break;

	return relevantFacts;
}

vector<double> computeFactWeights(vector<double> citizensFinalWeights, vector<vector<pair<int, int> > > votes)
{
	int nCitizens = citizensFinalWeights.size();
	int nFacts = votes.size();
	vector<double> factsFinalWeights(nFacts, 0);

	for (int f = 0; f < nFacts; f++)
	{
		for (int c = 0; c < nCitizens; c++)
		{
			int factVotes = votes[f][c].first;
			int replicVotes = votes[f][c].first;
			factsFinalWeights[f] += (replicVotes + factVotes) * citizensFinalWeights[c];
		}
	}

	return factsFinalWeights;
}

static bool comparacaoMaior(int a, int b)
{
	return (a > b);
}

vector<int> returnMostRelevantFactWithDeletes(vector<double> citizensFinalWeights, vector<vector<pair<int, int> > > votes, vector<int> factsProposers)
{
	vector<int> relevantFacts;

	bool nextIter = true;
	while (nextIter)
	{
		vector<double> factsFinalsWeight = computeFactWeights(citizensFinalWeights, votes);

		int nFacts = factsFinalsWeight.size();
		vector<pair<double, int> > weightsPerIndex;

		for (int f = 0; f < nFacts; f++)
		{
			weightsPerIndex.push_back(make_pair(factsFinalsWeight[f], f));
		}

		sort(weightsPerIndex.begin(), weightsPerIndex.end(), comparacao);

		bool deleted = false;
		relevantFacts.clear();
		for (int f = 0; f < nFacts; f++)
		{
			if (weightsPerIndex[f].first < 0)
				relevantFacts.push_back(weightsPerIndex[f].second);
			else
			{

				int proposed = factsProposers[f];
				//				cout << proposed << endl;
				factsProposers[f] = -1;

				if (proposed != -1)
				{
					deleted = true;
					//===========================
					//exclude who proposed
					citizensFinalWeights.erase(citizensFinalWeights.begin() + proposed);
					//exclude citizens votes
					for (int fv = 0; fv < votes.size(); fv++)
						votes[fv].erase(votes[fv].begin() + proposed);

					for (int fp = 0; fp < factsProposers.size(); fp++)
					{
						if (factsProposers[fp] == proposed)
							factsProposers[fp] = -1;

						if (factsProposers[fp] > proposed)
							factsProposers[fp]--;
					}
//					cout << factsProposers << endl;
//					cout << citizensFinalWeights << endl;
//					getchar();

				}

				//===========================
				//delete who proposed
//				int proposed = factsProposers[f];
////				cout << proposed << endl;
//				vector<int> otherFacts;
//				for (int fp = 0; fp < factsProposers.size(); fp++)
//					if (factsProposers[fp] == proposed)
//						otherFacts.push_back(fp);
//				for (int fp = 0; fp < factsProposers.size(); fp++)
//					if (factsProposers[fp] > proposed)
//						factsProposers[fp]--;
//
//				sort(otherFacts.begin(), otherFacts.end(), comparacaoMaior);
////				cout << otherFacts << endl;
//				//deleting citizen
//				citizensFinalWeights.erase(citizensFinalWeights.begin() + proposed);
//
//				//deleting citizen votes
//				for (int fv = 0; fv < votes.size(); fv++)
//					votes[fv].erase(votes[fv].begin() + proposed);
//
//				//deleting factsProposers
//				for (int of = 0; of < otherFacts.size(); of++)
//				{
//					factsProposers.erase(factsProposers.begin() + otherFacts[of]);
//					votes.erase(votes.begin() + otherFacts[of]);
//				}
//
//				cout << factsProposers << endl;
//				cout << votes.size() << "\t" << factsProposers.size() << endl;
//				cout << weightsPerIndex << endl;
//				cout << citizensFinalWeights << endl;
//				getchar();
//				deleted = true;
//				break;
			}
		}

		if (deleted == false)
			nextIter = false;
	}

	return relevantFacts;
}

vector<double> computeCitizensWeights(vector<vector<double> > profilePonderatedWeights, vector<vector<int> > citizensProfile)
{
	int nCitizens = citizensProfile[0].size();
	int nCarac = citizensProfile.size();
	vector<double> citzensFinalWeights(nCitizens, 0);

	for (int carac = 0; carac < nCarac; carac++)
	{
		for (int c = 0; c < nCitizens; c++)
		{
			int citizensValues = citizensProfile[carac][c];
			double weight = profilePonderatedWeights[carac][citizensValues];
			citzensFinalWeights[c] += weight;
		}
	}

	return citzensFinalWeights;
}

vector<vector<int> > generateWeights(RandGenMersenneTwister& rg, vector<int> vChar)
{
	vector<vector<int> > profileWeights;

	for (int carac = 0; carac < vChar.size(); carac++)
	{
		vector<int> weightsCarac;
		for (int p = 0; p < vChar[carac]; p++)
			weightsCarac.push_back(rg.rand(11));
		profileWeights.push_back(weightsCarac);
	}

	return profileWeights;

}

double calculateProfilesDesv(vector<vector<int> > profileWeights)
{
	int nCharacteristics = profileWeights.size();

	double totalDesv = 0;
	for (int p = 0; p < nCharacteristics; p++)
	{
		double sum = 0;
		int nCarac = profileWeights[p].size();
		for (int w = 0; w < nCarac; w++)
			sum += profileWeights[p][w];
		double mean = sum / nCarac;

		double desv = 0;
		for (int w = 0; w < nCarac; w++)
			if (sum != 0)
				desv += pow(profileWeights[p][w] - mean, 2);
			else
				desv += 0;
		desv /= nCarac;

		desv = sqrt(desv);
		totalDesv += desv;
	}

	return totalDesv;

}

vector<vector<double> > ponderateWeights(vector<vector<int> > profileWeights)
{
	int nCharacteristics = profileWeights.size();
	vector<vector<double> > profilePonderatedWeights(nCharacteristics);

	for (int p = 0; p < nCharacteristics; p++)
	{
		vector<double> characteristic(profileWeights[p].size());
		profilePonderatedWeights[p] = characteristic;
	}

	for (int p = 0; p < nCharacteristics; p++)
	{
		double sum = 0;
		for (int w = 0; w < profileWeights[p].size(); w++)
			sum += profileWeights[p][w];

		for (int w = 0; w < profileWeights[p].size(); w++)
			if (sum != 0)
				profilePonderatedWeights[p][w] = profileWeights[p][w] / sum;
			else
				profilePonderatedWeights[p][w] = 0;

	}

	return profilePonderatedWeights;

}

unsigned long mix(unsigned long a, unsigned long b, unsigned long c)
{
	a = a - b;
	a = a - c;
	a = a ^ (c >> 13);
	b = b - c;
	b = b - a;
	b = b ^ (a << 8);
	c = c - a;
	c = c - b;
	c = c ^ (b >> 13);
	a = a - b;
	a = a - c;
	a = a ^ (c >> 12);
	b = b - c;
	b = b - a;
	b = b ^ (a << 16);
	c = c - a;
	c = c - b;
	c = c ^ (b >> 5);
	a = a - b;
	a = a - c;
	a = a ^ (c >> 3);
	b = b - c;
	b = b - a;
	b = b ^ (a << 10);
	c = c - a;
	c = c - b;
	c = c ^ (b >> 15);
	return c;
}

vector<int> generateFactsPerCitizens(RandGenMersenneTwister& rg, int nCitizens)
{
	vector<int> factProposer;

	for (int c = 0; c < nCitizens; c++)
	{
		int propose = rg.rand(10);
		if (propose < 5)
		{
//			int nFacts = rg.rand(3) + 1;
			int nFacts = 1;
			for (int f = 0; f < nFacts; f++)
			{
				factProposer.push_back(c);
			}
		}
	}

	return factProposer;
}

int main(int argc, char **argv)
{
	cout << "A multicriteria view about judgements..." << endl;

	RandGenMersenneTwister rg;
	//long  1412730737
//	long seed = time(NULL); //CalibrationMode
//	struct timeval time;
//	     gettimeofday(&time,NULL);
//	     long seed = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	unsigned long seed = rg.generateRandomSeed();
//	     unsigned long seed = mix(clock(), time(NULL), getpid());
//	long seed = (unsigned) time(NULL) * getpid();
//	seed = 0;
	cout << "Seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);

	int nCitizens = rg.rand(100) + 10;
	int nCarac = rg.rand(30) + 1;
	int nRandomWeights = (rg.rand(10) + 1) * 1000;
	int nFacts = rg.rand(100) + 1;

//
//	nCitizens = 200;
//	nCarac = 3;
////	nFacts = 100;
//	nRandomWeights = 1000;
//	vector<int> factsProposers = generateFactsPerCitizens(rg, nCitizens);
//	int nFacts = factsProposers.size();
//	cout << factsProposers << endl;
//	cout<<"number of random weights:" <<nRandomWeights<<endl;

	vector<vector<int> > citizensProfile;

//	O tamanho deve vector deve ser exatamente nChar
//	vector<int> characteristicFactors =
//	{ 3, 2, 2, 5, 10 };

	vector<int> characteristicFactors;
	for (int carac = 0; carac < nCarac; carac++)
		characteristicFactors.push_back(rg.rand(2) + 2);

//	vector<int> characteristicFactors =
//	{ 3, 2, 2 };

	cout << "\n There are " << nCitizens << " citizens. Their profile ( with " << nCarac << " characteristics goes as follow:" << endl;

	for (int carac = 0; carac < nCarac; carac++)
	{
		vector<int> citizensChar;
		for (int c = 0; c < nCitizens; c++)
		{
			citizensChar.push_back(rg.rand(characteristicFactors[carac]));
		}
		citizensProfile.push_back(citizensChar);
	}

	cout << "citizens characteristics:" << endl;
	cout << citizensProfile << endl;

//	======================================================
	vector<vector<pair<int, int> > > votes;

	cout << "\nTime for random voting. \nPrinting votes per fact:" << endl;

	for (int f = 0; f < nFacts; f++)
	{
		cout << "Fato " << f + 1 << ": " << endl;
		vector<pair<int, int> > citizensVotesForFactAndReplic;
		for (int aC = 0; aC < nCitizens; aC++)
		{

			int voteFact = rg.rand(11);
			int voteReplica = rg.rand(11);
			int sign = rg.rand(2);
			if (sign == 1)
				voteFact *= -1;
			sign = rg.rand(2);
			if (sign == 1)
				voteReplica *= -1;

			citizensVotesForFactAndReplic.push_back(make_pair(voteFact, voteReplica));

		}
		votes.push_back(citizensVotesForFactAndReplic);
		cout << citizensVotesForFactAndReplic << endl;
	}

//	cout << votes << endl;

//	vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);
//
//	cout << "Profile weights:" << endl;
//	cout << profileWeights << endl;
//
//	vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);
//	cout << "Profile ponderated weights:" << endl;
//	cout << profilePonderatedWeights << endl;
//
//	vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights,citizensProfile);
//	cout << "Profile citizens final weights:" << endl;
//cout<<citizensFinalWeights<<endl;
//
//vector<double> factFinalsWeight = computeFactWeights(citizensFinalWeights,votes);
//cout << "facts final weights:" << endl;
//cout<<factFinalsWeight<<endl;

	vector<solDireitoDoFuturo> nonDominatedSolutions;
	for (int i = 0; i < nRandomWeights; i++)
	{
//		vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);
//		vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);
//		vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights, citizensProfile);

		vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);

		double profilesStdDesv = calculateProfilesDesv(profileWeights);

		vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);

		vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights, citizensProfile);

		vector<double> factFinalsWeight = computeFactWeights(citizensFinalWeights, votes);

		vector<int> relevantFacts = returnMostRelevantFact(factFinalsWeight);

//		vector<int> relevantFacts = returnMostRelevantFactWithDeletes(citizensFinalWeights, votes, factsProposers);

//		cout << "Profile weights:" << endl;
//		cout << profileWeights << endl;
//		cout << "Profile ponderated weights:" << endl;
//		cout << profilePonderatedWeights << endl;
//		cout << "profilesStdDesv:" << endl;
//		cout << profilesStdDesv << endl;
//		cout << "Profile citizens final weights:" << endl;
//		cout << citizensFinalWeights << endl;
//		cout << "facts final weights:" << endl;
//		cout << factFinalsWeight << endl;
//		cout << "relevantFacts:" << endl;
//		cout << relevantFacts << endl;
//		//		getchar();

		solDireitoDoFuturo sol(profileWeights, votes, relevantFacts, profilesStdDesv);

		addSolution(nonDominatedSolutions, sol);

	}
	cout << "final vector contains " << nonDominatedSolutions.size() << " solutions..." << endl;
//	cout<<nonDominatedSolutions<<endl;

// =================== PRINTING RESULTS ON FILE ========================
	FILE* fResults = fopen("./calibrationWithSameElements", "a");
	fprintf(fResults, "%d\t%d\t%d\t%d\t%d\t%ld\n", int(nonDominatedSolutions.size()), nCitizens, nCarac, nFacts, nRandomWeights, seed);
	fclose(fResults);
	// =======================================================

	cout << "\nFinished com sucesso!!" << endl;
	return 0;

}

