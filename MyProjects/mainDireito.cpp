// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <iomanip>
#include <numeric>
#include "../OptFrame/Util/RandGenMersenneTwister.hpp"
#include "../OptFrame/Util/printable.h"
#include "../OptFrame/RandGen.hpp"

using namespace std;
using namespace optframe;

//int computeFacts(vector<vector<pair<int, int> > > votes, vector<vector<int> > profileWeights, vector<vector<int> > citizensProfile)
//{
//	int nFacts = votes.size();
//	int nVoters = citizensProfile[0].size();
//
//
//	for(int f=0;f<nFacts;f++)
//	{
//		vector<int> scores;
//		int sum = 0;
//		for(int c=0;c<nVoters;c++)
//			{
//			sum+=votes[f][c].first *
//			}
//	}
//
//}

struct solDireitoDoFuturo
{
	vector<vector<int> > profileWeights;
	vector<vector<pair<int, int> > > votes;
	vector<int> relevantFacts;
	double stdProfile;

	solDireitoDoFuturo(vector<vector<int> > _profileWeights, vector<vector<pair<int, int> > > _votes, vector<int> _relevantFacts, double _stdProfile) :
			profileWeights(_profileWeights), votes(_votes), relevantFacts(_relevantFacts), stdProfile(_stdProfile)
	{

	}
//
	friend ostream & operator<<(ostream & os, const solDireitoDoFuturo& sol)
	{

		os << "=======================================" << endl;
		os << "==========PRINTING SOL ===============" << endl;
		os << "=======================================" << endl;
		os << "Profile weights:" << endl;
		os << sol.profileWeights << endl;
		os << "stdProfile:" << endl;
		os << sol.stdProfile << endl;
		os << "relevantFacts:" << endl;
		os << sol.relevantFacts << endl;
		os << "=======================================" << endl;

		return os;
	}

};

bool addSolution(vector<solDireitoDoFuturo>& nonDom, solDireitoDoFuturo candidateSol)
{
	bool added = false;


	for (int ind = 0; ind < nonDom.size(); ind++)
	{
		if (nonDom[ind].relevantFacts == candidateSol.relevantFacts)
		{
			if (nonDom[ind].stdProfile <= candidateSol.stdProfile)
			{
				return false;
			}
			else
			{
				nonDom.erase(nonDom.begin() + ind);
				ind--;
			}
		}

	}
	added = true;
	nonDom.push_back(candidateSol);

	return added;
}

static bool comparacao(pair<double, int> a, pair<double, int> b)
{
	return (a.first < b.first);
}

vector<int> returnMostRelevantFact(vector<double> factsFinalWeights)
{
	vector<int> relevantFacts;
	int nFacts = factsFinalWeights.size();
	vector<pair<double, int> > weightsPerIndex;

	for (int f = 0; f < nFacts; f++)
	{
		weightsPerIndex.push_back(make_pair(factsFinalWeights[f], f));
	}

	sort(weightsPerIndex.begin(), weightsPerIndex.end(), comparacao);

	for (int f = 0; f < nFacts; f++)
		if (weightsPerIndex[f].first < 0)
			relevantFacts.push_back(weightsPerIndex[f].second);
		else
			break;

	return relevantFacts;
}

vector<double> computeFactWeights(vector<double> citizensFinalWeights, vector<vector<pair<int, int> > > votes)
{
	int nCitizens = citizensFinalWeights.size();
	int nFacts = votes.size();
	vector<double> factsFinalWeights(nFacts, 0);

	for (int f = 0; f < nFacts; f++)
	{
		for (int c = 0; c < nCitizens; c++)
		{
			int factVotes = votes[f][c].first;
			int replicVotes = votes[f][c].first;
			factsFinalWeights[f] += (replicVotes + factVotes) * citizensFinalWeights[c];
		}
	}

	return factsFinalWeights;
}

vector<double> computeCitizensWeights(vector<vector<double> > profilePonderatedWeights, vector<vector<int> > citizensProfile)
{
	int nCitizens = citizensProfile[0].size();
	int nCarac = citizensProfile.size();
	vector<double> citzensFinalWeights(nCitizens, 0);

	for (int carac = 0; carac < nCarac; carac++)
	{
		for (int c = 0; c < nCitizens; c++)
		{
			int citizensValues = citizensProfile[carac][c];
			double weight = profilePonderatedWeights[carac][citizensValues];
			citzensFinalWeights[c] += weight;
		}
	}

	return citzensFinalWeights;
}

vector<vector<int> > generateWeights(RandGenMersenneTwister& rg, vector<int> vChar)
{
	vector<vector<int> > profileWeights;

	for (int carac = 0; carac < vChar.size(); carac++)
	{
		vector<int> weightsCarac;
		for (int p = 0; p < vChar[carac]; p++)
			weightsCarac.push_back(rg.rand(11));
		profileWeights.push_back(weightsCarac);
	}

	return profileWeights;

}

double calculateProfilesDesv(vector<vector<int> > profileWeights)
{
	int nCharacteristics = profileWeights.size();

	double totalDesv = 0;
	for (int p = 0; p < nCharacteristics; p++)
	{
		double sum = 0;
		int nCarac = profileWeights[p].size();
		for (int w = 0; w < nCarac; w++)
			sum += profileWeights[p][w];
		double mean = sum / nCarac;

		double desv = 0;
		for (int w = 0; w < nCarac; w++)
			if (sum != 0)
				desv += pow(profileWeights[p][w] - mean, 2);
			else
				desv += 0;
		desv /= nCarac;

		desv = sqrt(desv);
		totalDesv += desv;
	}

	return totalDesv;

}

vector<vector<double> > ponderateWeights(vector<vector<int> > profileWeights)
{
	int nCharacteristics = profileWeights.size();
	vector<vector<double> > profilePonderatedWeights(nCharacteristics);

	for (int p = 0; p < nCharacteristics; p++)
	{
		vector<double> characteristic(profileWeights[p].size());
		profilePonderatedWeights[p] = characteristic;
	}

	for (int p = 0; p < nCharacteristics; p++)
	{
		double sum = 0;
		for (int w = 0; w < profileWeights[p].size(); w++)
			sum += profileWeights[p][w];

		for (int w = 0; w < profileWeights[p].size(); w++)
			if (sum != 0)
				profilePonderatedWeights[p][w] = profileWeights[p][w] / sum;
			else
				profilePonderatedWeights[p][w] = 0;

	}

	return profilePonderatedWeights;

}

int main(int argc, char **argv)
{
	cout << "A multicriteria view about judgements..." << endl;

	RandGenMersenneTwister rg;
	//long  1412730737
	long seed = time(NULL); //CalibrationMode
	seed = 0;
	cout << "Seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);

	int nCitizens = 15;

	int nChar = 3;
	vector<vector<int> > citizensProfile;

//	O tamanho deve vector deve ser exatamente nChar
//	vector<int> characteristicFactors =
//	{ 3, 2, 2, 5, 10 };

	vector<int> characteristicFactors =
	{ 3, 2, 2 };

	cout << "\n There are " << nCitizens << " citizens. Their profile characteristics goes as follow:" << endl;

	for (int carac = 0; carac < nChar; carac++)
	{
		vector<int> citizensChar;
		for (int c = 0; c < nCitizens; c++)
		{
			citizensChar.push_back(rg.rand(characteristicFactors[carac]));
		}
		citizensProfile.push_back(citizensChar);
	}

	cout << "citizens characteristics:" << endl;
	cout << citizensProfile << endl;

//	======================================================

	int nFacts = 7;
	vector<vector<pair<int, int> > > votes;

	cout << "\nTime for random voting. \nPrinting votes per fact:" << endl;

	int nCitizensThatVoted = 15;
	for (int f = 0; f < nFacts; f++)
	{
		cout << "Fato " << f + 1 << ": " << endl;
		vector<pair<int, int> > citizensVotesForFactAndReplic;
		for (int aC = 0; aC < nCitizensThatVoted; aC++)
		{

			int voteFact = rg.rand(11);
			int voteReplica = rg.rand(11);
			int sign = rg.rand(2);
			if (sign == 1)
				voteFact *= -1;
			sign = rg.rand(2);
			if (sign == 1)
				voteReplica *= -1;

			citizensVotesForFactAndReplic.push_back(make_pair(voteFact, voteReplica));

		}
		votes.push_back(citizensVotesForFactAndReplic);
		cout << citizensVotesForFactAndReplic << endl;
	}

//	cout << votes << endl;

//	vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);
//
//	cout << "Profile weights:" << endl;
//	cout << profileWeights << endl;
//
//	vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);
//	cout << "Profile ponderated weights:" << endl;
//	cout << profilePonderatedWeights << endl;
//
//	vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights,citizensProfile);
//	cout << "Profile citizens final weights:" << endl;
//cout<<citizensFinalWeights<<endl;
//
//vector<double> factFinalsWeight = computeFactWeights(citizensFinalWeights,votes);
//cout << "facts final weights:" << endl;
//cout<<factFinalsWeight<<endl;

	vector<solDireitoDoFuturo> nonDominatedSolutions;
	for (int i = 0; i < 10000; i++)
	{
//		vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);
//		vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);
//		vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights, citizensProfile);

		vector<vector<int> > profileWeights = generateWeights(rg, characteristicFactors);


		double profilesStdDesv = calculateProfilesDesv(profileWeights);


		vector<vector<double> > profilePonderatedWeights = ponderateWeights(profileWeights);


		vector<double> citizensFinalWeights = computeCitizensWeights(profilePonderatedWeights, citizensProfile);


		vector<double> factFinalsWeight = computeFactWeights(citizensFinalWeights, votes);


		vector<int> relevantFacts = returnMostRelevantFact(factFinalsWeight);

//		cout << "Profile weights:" << endl;
//		cout << profileWeights << endl;
//		cout << "Profile ponderated weights:" << endl;
//		cout << profilePonderatedWeights << endl;
//		cout << "profilesStdDesv:" << endl;
//		cout << profilesStdDesv << endl;
//		cout << "Profile citizens final weights:" << endl;
//		cout << citizensFinalWeights << endl;
//		cout << "facts final weights:" << endl;
//		cout << factFinalsWeight << endl;
//		cout << "relevantFacts:" << endl;
//		cout << relevantFacts << endl;

		solDireitoDoFuturo sol(profileWeights, votes, relevantFacts, profilesStdDesv);

		addSolution(nonDominatedSolutions, sol);
//		getchar();

	}
	cout<<"final vector contains "<<nonDominatedSolutions.size()<<" solutions..."<<endl;
	cout<<nonDominatedSolutions<<endl;

	cout << "\nFinished com sucesso!!" << endl;
	return 0;

}

